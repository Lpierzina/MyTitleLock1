<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>MyTitleLock - Lock Down Your Title</title>

    <!-- Include Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <!-- PayPal SDK (Replace with your own CLIENT-ID) -->
    <script src="https://www.paypal.com/sdk/js?client-id=REPLACE_WITH_YOUR_PAYPAL_CLIENT_ID&currency=USD"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            margin: 0;
            padding: 0;
        }
        .navbar {
            background-color: #1e429f;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .navbar h1 {
            margin: 0;
            font-size: 24px;
            line-height: 1.2;
            color: white;
        }
        .container {
            max-width: 900px;
            margin: 40px auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3 {
            color: #1e429f;
        }
        button {
            background-color: #1e429f;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        input[type="file"], input[type="text"] {
            margin: 20px 0;
            padding: 10px;
            width: calc(100% - 22px);
            box-sizing: border-box;
        }
        #hashOutput {
            word-break: break-word;
            margin: 20px 0;
            color: #1e429f;
        }
        #receipt {
            display: none;
            background-color: #e6f7ff;
            border: 2px solid #1e429f;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .footer {
            text-align: center;
            margin-top: 50px;
            color: #777;
        }
        #retrievedLink {
            display: none;
            color: #1e429f;
            text-decoration: underline;
            margin-top: 10px;
        }

        /* Section styling */
        .hidden-section {
            margin-top: 20px;
            padding: 15px;
            background: #fffcee;
            border: 1px solid #f7daa3;
            border-radius: 5px;
            display: none; /* hidden by default */
        }
        .ipfs-section, .blockchain-section {
            margin-top: 30px;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 5px;
        }
        .ipfs-section h3, .blockchain-section h3 {
            margin-top: 0;
        }

        /* Collapsible section buttons */
        .toggle-buttons {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

    </style>
</head>

<body>
<div class="navbar">
    <h1>MyTitleLock - Lock Down Your Title</h1>
</div>

<div class="container">

    <!-- Intro / Summary -->
    <h2>Welcome to MyTitleLock</h2>
    <p>
        Manage and verify title deeds securely using blockchain and IPFS technology. 
        By uploading a title deed, we generate a unique "hash" for the document, 
        which acts like a digital fingerprint. This hash is stored securely on the 
        blockchain, ensuring tamper-proof authenticity. The hashing process is a 
        one-way mathematical function that converts your document into a fixed 
        string of characters, making it impossible to recreate the original document 
        from the hash. This ensures that your title deed is both private and secure, 
        while allowing easy verification of its integrity.
    </p>

    <!-- Buttons to show/hide the hidden sections -->
    <div class="toggle-buttons">
        <button onclick="toggleSection('whyStoreSection')">Why Store Documents on MyTitleLock?</button>
        <button onclick="toggleSection('ipfsIntroSection')">Introducing IPFS</button>
    </div>

    <!-- Collapsible Section 1: Why Store Documents? -->
    <div id="whyStoreSection" class="hidden-section">
        <h3>Why Store Documents on MyTitleLock?</h3>
        <h4>Prevent Tampering &amp; Fraud</h4>
        <p>
            By hashing your file and storing that hash on the blockchain, you create 
            an unchangeable proof that the document existed exactly as-is at the time 
            of registration. If anyone edits the document, the hash no longer matches—instantly 
            revealing any forgery.
        </p>
        <h4>Decentralized &amp; Always Accessible</h4>
        <p>
            Traditional storage can fail if a single server goes down or a company closes. 
            But IPFS spreads files across many computers worldwide. Even if one “node” is offline, 
            others keep the file available. Your important records stay safe and globally accessible.
        </p>
        <h4>Privacy &amp; Security</h4>
        <p>
            <strong>Privacy:</strong> Only the file’s hash goes onto the blockchain—not the 
            actual file. This means no one can read your document just by looking at the 
            blockchain record.
        </p>
        <p>
            <strong>Security:</strong> Because IPFS uses cryptographic hashes, any small 
            change creates a new hash. This prevents hidden alterations or data manipulation.
        </p>
        <h4>Lower Costs</h4>
        <p>
            Storing large files on a centralized service can be expensive, but with IPFS, 
            you pay primarily for what you choose to “pin.” Our fee structure ensures 
            you pay only for the file sizes you actually upload—nothing more.
        </p>
        <h4>Future-Proof for Legal Needs</h4>
        <p>
            In a dispute, you can produce your tamper-proof, time-stamped hash from the 
            blockchain and retrieve the exact file from IPFS. This level of immutability 
            is invaluable for title deeds, contracts, insurance documents, or any record 
            requiring legal certainty.
        </p>
        <h4>Easy Setup with Your Wallet</h4>
        <p>
            MyTitleLock integrates directly with MetaMask or Coinbase Wallet. One click 
            connects your wallet, and a small ETH fee registers your file’s hash on the 
            blockchain. It’s as simple as uploading your document and clicking 
            “Register on Blockchain.”
        </p>
        <h4>How It All Works</h4>
        <p>
            <strong>Upload Document</strong> &rarr; We generate a unique hash using a 
            one-way function.<br/>
            <strong>Store on IPFS</strong> &rarr; Your file is distributed across a peer-to-peer network, 
            ensuring resilient, censorship-proof access.<br/>
            <strong>Register on Blockchain</strong> &rarr; The hash is permanently recorded, 
            creating a proof of existence. No central authority can alter or remove it.
        </p>
        <h4>Start Protecting Your Documents Now</h4>
        <p>
            With MyTitleLock, your documents are safer, always retrievable, and legally verifiable. 
            Why trust a single server or paper record when you can harness the power of decentralization? 
            Upload today, and experience peace of mind knowing your titles, deeds, or critical records 
            are truly locked down.
        </p>
    </div>

    <!-- Collapsible Section 2: Introducing IPFS -->
    <div id="ipfsIntroSection" class="hidden-section">
        <h3>Introducing IPFS: Safe &amp; Decentralized Document Storage</h3>
        <p>
            <strong>What Is IPFS?</strong><br/>
            IPFS (InterPlanetary File System) is a global, peer-to-peer file network that breaks your file 
            into small pieces and stores them across many computers worldwide. Instead of depending on a 
            single server or company, your file is spread out and always accessible.
        </p>
        <h4>Why It’s Safe</h4>
        <ul>
            <li><strong>Redundant &amp; Decentralized:</strong> No single point of failure—if one node goes down,
                other nodes still have your file.</li>
            <li><strong>Content-Based Addressing:</strong> Every file is located by its unique cryptographic hash.
                If anyone changes even one letter in your file, the hash changes, exposing tampering.</li>
            <li><strong>Immutable Storage:</strong> Since each file fragment is verified against its hash, no one
                can alter it without creating a brand-new hash. This makes your documents effectively tamper-proof.</li>
        </ul>
        <h4>Try It for Free (Up to 0.5MB)</h4>
        <p>
            MyTitleLock allows free uploads for files under 0.5MB. Upload a small document, 
            see how the hash and IPFS storage work, and experience the benefits of decentralized 
            storage—all at no charge!
        </p>
        <h4>Secure Registration with Blockchain &amp; PayPal</h4>
        <p>
            <strong>Blockchain Registration:</strong> We store your document’s unique hash on the blockchain 
            for a tamper-proof record. No one—not even us—can alter it after it’s recorded.
        </p>
        <p>
            <strong>PayPal-Enabled:</strong> For files larger than 0.5MB, we charge a small fee (based on file size)
            to cover IPFS pinning and blockchain costs. You can easily pay using PayPal, a secure, globally recognized 
            payment method. Once confirmed, we finalize your IPFS upload and registration on the blockchain.
        </p>
        <h4>How It Works in 3 Easy Steps</h4>
        <ol>
            <li><strong>Upload:</strong> Select your PDF and click “Upload &amp; Hash.” Files under 0.5MB are free; for
                larger files, you can pay with PayPal.</li>
            <li><strong>Register:</strong> We record the hash on the blockchain, creating a tamper-proof record of ownership.</li>
            <li><strong>Verify:</strong> Anyone can re-hash the file and compare it to the on-chain record. If they match,
                the file is authentic.</li>
        </ol>
        <h4>Why Trust MyTitleLock?</h4>
        <ul>
            <li><strong>User-Friendly:</strong> We handle the hashing and registration. No deep blockchain knowledge needed.</li>
            <li><strong>Affordable:</strong> Pay only for the exact storage you need. Under 0.5MB is free!</li>
            <li><strong>Flexible Payments:</strong> We support ETH transaction fees and PayPal for bigger files—no crypto required.</li>
            <li><strong>Future-Proof:</strong> IPFS + blockchain ensures long-term, censorship-resistant availability.</li>
        </ul>
        <p>
            <strong>Ready to Protect Your Documents?</strong><br/>
            - Give It a Try: Upload a small file (0.5MB or less) for free.<br/>
            - Secure Larger Documents: Pay via PayPal for bigger files.<br/>
            - Rest Easy: Your files remain immutable and verifiable—today, tomorrow, or years down the line.
        </p>
    </div>

    <!-- IPFS SECTION: actual file upload process -->
    <div class="ipfs-section">
        <h3>Upload &amp; Hash Your Document (IPFS)</h3>
        <p>
            Files over 50MB are not accepted. Below is our Fee Structure:
        </p>
        <ul>
            <li>Up to 0.5MB: FREE</li>
            <li>0.5MB &ndash; 5MB: $5</li>
            <li>5MB &ndash; 20MB: $10</li>
            <li>20MB &ndash; 50MB: $20</li>
        </ul>

        <input type="file" id="fileInput" accept=".pdf" />
        <button id="uploadBtn" onclick="handleFileAndPayment()">Upload and Hash Document</button>
        <p id="fileNameOutput"></p>
        <p id="hashOutput"></p>
    </div>

    <!-- PayPal button container (hidden by default) -->
    <div id="paypal-button-container" style="display:none; margin-bottom:20px;"></div>

    <!-- BLOCKCHAIN SECTION: connect wallet and register on-chain -->
    <div class="blockchain-section">
        <h3>Register on the Blockchain</h3>
        <p>
            A small ETH fee is required to record your document hash on the blockchain.
            This ensures tamper-proof authenticity and makes your record publicly verifiable.
        </p>

        <h4>Connect Your Wallet</h4>
        <button onclick="connectWallet('metamask')">Connect MetaMask</button>
        <button onclick="connectWallet('coinbase')">Connect Coinbase Wallet</button>
        <button onclick="disconnectWallet()">Disconnect Wallet</button>
        <p id="walletAddress">Not connected</p>

        <button id="registerButton" onclick="registerHashOnBlockchain()" disabled>Register on Blockchain</button>

        <div id="receipt">
            <h3>Transaction Receipt</h3>
            <p id="receiptContent"></p>
            <div id="qrCode" style="margin-top:10px;"></div>
            <p style="color:red; margin-top:15px;">
                <strong>IMPORTANT:</strong> Save or print this receipt!
                You will need this information and/or the QR code to verify or retrieve your document in the future.
            </p>
        </div>
    </div>

    <h3>Verify Title Deed</h3>
    <button onclick="verifyDocument()">Verify Document</button>

    <h3>Retrieve Title Deed</h3>
    <input type="text" id="retrieveHash" placeholder="Enter IPFS Hash" />
    <button onclick="retrieveDocument()">Retrieve Document</button>
    <a id="retrievedLink" href="#" target="_blank">Download Document</a>

</div>

<!-- Spinner Overlay -->
<div id="loadingOverlay">
    <div class="spinner"></div>
    <p style="color: white; font-size: 20px; text-align: center;">
        Processing... Please wait.
    </p>
</div>

<div class="footer">
    &copy; 2023 MyTitleLock. All Rights Reserved.
</div>

<script>
    let web3;
    let contract;
    let account;
    let hashHex;
    let ipfsHash;
    let selectedProvider;

    let lastUploadedFileName = ''; // store the file name to show in receipt
    let uploadCostUSD = 0;         // how much the user must pay based on file size
    let fileToUpload = null;       // store the actual File object for reference

    
    // Contract ABI
    const contractABI = [
        {
            "type": "constructor",
            "inputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "fee",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "getDocumentDetails",
            "inputs": [
                {
                    "name": "_hash",
                    "type": "bytes32",
                    "internalType": "bytes32"
                }
            ],
            "outputs": [
                {
                    "name": "hash",
                    "type": "bytes32",
                    "internalType": "bytes32"
                },
                {
                    "name": "timestamp",
                    "type": "uint256",
                    "internalType": "uint256"
                },
                {
                    "name": "registrant",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "getFee",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "isDocumentRegistered",
            "inputs": [
                {
                    "name": "_hash",
                    "type": "bytes32",
                    "internalType": "bytes32"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "bool",
                    "internalType": "bool"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "owner",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "registerDocument",
            "inputs": [
                {
                    "name": "_hash",
                    "type": "bytes32",
                    "internalType": "bytes32"
                }
            ],
            "outputs": [],
            "stateMutability": "payable"
        },
        {
            "type": "function",
            "name": "renounceOwnership",
            "inputs": [],
            "outputs": [],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "setFee",
            "inputs": [
                {
                    "name": "_newFee",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "transferOwnership",
            "inputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "outputs": [],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "withdrawFees",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "event",
            "name": "DocumentRegistered",
            "inputs": [
                {
                    "name": "hash",
                    "type": "bytes32",
                    "indexed": true,
                    "internalType": "bytes32"
                },
                {
                    "name": "registrant",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "timestamp",
                    "type": "uint256",
                    "indexed": false,
                    "internalType": "uint256"
                }
            ],
            "anonymous": false
        },
        {
            "type": "event",
            "name": "OwnershipTransferred",
            "inputs": [
                {
                    "name": "previousOwner",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "newOwner",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                }
            ],
            "anonymous": false
        },
        {
            "type": "error",
            "name": "OwnableInvalidOwner",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        },
        {
            "type": "error",
            "name": "OwnableUnauthorizedAccount",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        }
    ];

    // Contract address
    const contractAddress = '0xca2f282ab9d7b2ae33FDe040142C1c185B6591b4';

    // 1) Connect Wallet
    async function connectWallet(wallet) {
        if (wallet === 'metamask') {
            if (window.ethereum && window.ethereum.isMetaMask) {
                selectedProvider = window.ethereum;
            } else {
                alert('MetaMask is not installed. Please install MetaMask and try again.');
                return;
            }
        } else if (wallet === 'coinbase') {
            const coinbaseWallet = new CoinbaseWalletSDK({
                appName: 'LockChain',
                appLogoUrl: 'https://yourapp.com/logo.png',
                darkMode: false
            });
            const coinbaseProvider = coinbaseWallet.makeWeb3Provider();
            selectedProvider = coinbaseProvider;
        } else {
            alert('Unsupported wallet selected');
            return;
        }

        try {
            web3 = new Web3(selectedProvider);
            await selectedProvider.request({ method: 'eth_requestAccounts' });
            const accounts = await web3.eth.getAccounts();
            account = accounts[0];
            document.getElementById('walletAddress').innerText = 'Connected: ' + account;
            contract = new web3.eth.Contract(contractABI, contractAddress);

            // Check network
            await checkNetwork();
            // Fetch and display fee
            await displayCurrentFee();

            console.log('Connected account:', account);
        } catch (error) {
            console.error('Error connecting to wallet:', error);
            alert('Error connecting to wallet.');
        }
    }

    // 2) Disconnect Wallet
    function disconnectWallet() {
        if (selectedProvider && selectedProvider.close) {
            selectedProvider.close();
        }
        selectedProvider = null;
        web3 = null;
        account = null;
        document.getElementById('walletAddress').innerText = 'Not connected';
        alert('Wallet disconnected');
    }

    // 3) Display Current Fee (on the smart contract side)
    async function displayCurrentFee() {
        try {
            const feeInWei = await contract.methods.getFee().call();
            const feeInEth = web3.utils.fromWei(feeInWei, 'ether');

            const feeNotice = document.createElement('p');
            feeNotice.id = 'feeNotice';
            feeNotice.innerText =
                `A small fee of ${feeInEth} ETH is required to register your document on the blockchain.`;

            const container = document.querySelector('.container');
            container.appendChild(feeNotice);
        } catch (error) {
            console.error('Error fetching current fee:', error);
            alert('Error fetching current fee from the contract.');
        }
    }

      // Toggles for Hidden Sections
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section.style.display === "none" || section.style.display === "") {
        section.style.display = "block";
      } else {
        section.style.display = "none";
      }
    }


    // Loading Overlay
    function toggleLoadingOverlay(show) {
        const loadingOverlay = document.getElementById('loadingOverlay');
        if (loadingOverlay) {
            loadingOverlay.style.display = show ? 'flex' : 'none';
        }
    }

    // Adjusted Fee Logic: Up to 0.5MB is free, 0.5–5MB => $5, 5–20MB => $10, 20–50MB => $20
    function determineFeeBySize(fileSizeBytes) {
        const sizeMB = fileSizeBytes / (1024 * 1024); // convert bytes to MB
        if (sizeMB > 50) {
            alert('File too large! Max limit is 50 MB.');
            return -1; // indicates an invalid file
        }
        if (sizeMB <= 0.5) {
            return 0;
        } else if (sizeMB <= 5) {
            return 5;
        } else if (sizeMB <= 20) {
            return 10;
        } else {
            // up to 50 MB
            return 20;
        }
    }

    // Step 2: Called when user clicks "Upload and Hash Document"
    async function handleFileAndPayment() {
        const fileInput = document.getElementById('fileInput');
        const selectedFile = fileInput.files[0];
        if (!selectedFile) {
            alert('Please select a PDF file first.');
            return;
        }
        // Check the size + fee
        const fee = determineFeeBySize(selectedFile.size);
        if (fee < 0) {
            // invalid file
            return;
        }
        fileToUpload = selectedFile;    // store globally
        uploadCostUSD = fee;           // store the cost

        // Show the file name
        lastUploadedFileName = selectedFile.name;
        document.getElementById('fileNameOutput').innerText = `File Name: ${selectedFile.name}`;

        if (fee === 0) {
            // No PayPal payment needed => directly upload to IPFS
            await uploadToIPFS();
        } else {
            // Show PayPal button for the fee
            showPayPalButton(fee);
        }
    }

    // Render the PayPal button for the given amount
    function showPayPalButton(amountUSD) {
        const paypalContainer = document.getElementById('paypal-button-container');
        paypalContainer.style.display = 'block'; // make it visible

        // Clean up any previously rendered button
        paypalContainer.innerHTML = '';

        paypal.Buttons({
            style: {
                layout: 'vertical',
                color: 'gold',
                shape: 'pill',
                label: 'paypal'
            },
            createOrder: function (data, actions) {
                return actions.order.create({
                    purchase_units: [{
                        amount: { value: amountUSD.toString() }
                    }]
                });
            },
            onApprove: function (data, actions) {
                return actions.order.capture().then(function (details) {
                    // Payment completed => now proceed with the IPFS upload
                    paypalContainer.style.display = 'none'; // hide PayPal UI
                    alert('Payment successful! Uploading file to IPFS...');
                    uploadToIPFS();
                });
            },
            onCancel: function (data) {
                alert('Payment canceled.');
            },
            onError: function (err) {
                console.error('PayPal error:', err);
                alert('An error occurred with PayPal. Check console for details.');
            }
        }).render('#paypal-button-container');
    }

    // 9) Actually upload to IPFS (after PayPal or if free)
    async function uploadToIPFS() {
        if (!fileToUpload) {
            alert('No file is selected. Please select a file first.');
            return;
        }
        toggleLoadingOverlay(true);
        try {
            const formData = new FormData();
            formData.append('file', fileToUpload);

            const response = await fetch(
                'https://polar-stream-23993-43b80ccd3a73.herokuapp.com/upload',
                {
                    method: 'POST',
                    body: formData
                }
            );
            if (!response.ok) {
                throw new Error('Failed to upload file to server.');
            }
            const data = await response.json();

            // IPFS Hash (from Pinata)
            ipfsHash = data.IpfsHash;
            document.getElementById('hashOutput').innerText = `IPFS Hash: ${ipfsHash}`;

            // Now do a separate SHA-256 of the file for the contract
            const arrayBuffer = await fileToUpload.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            hashHex = '0x' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            // Enable the "Register on Blockchain" button
            document.getElementById('registerButton').disabled = false;

            // Clear out fileToUpload (not strictly necessary)
            fileToUpload = null;
        } catch (error) {
            console.error('Error uploading file:', error);
            alert('Failed to upload file. Please try again.');
        } finally {
            toggleLoadingOverlay(false);
        }
    }

    // 4) Register Hash on Blockchain
    async function registerHashOnBlockchain() {
        if (!web3 || !account) {
            alert('Please connect your wallet first.');
            return;
        }
        if (!hashHex) {
            alert('Please hash a document first.');
            return;
        }

        toggleLoadingOverlay(true);
        try {
            const isRegistered = await contract.methods.isDocumentRegistered(hashHex).call();
            if (isRegistered) {
                alert('This document is already registered.');
                return;
            }

            // Get current fee from the contract (in ETH)
            const feeInWei = await contract.methods.getFee().call();

            // Send transaction
            const txReceipt = await contract.methods.registerDocument(hashHex).send({
                from: account,
                value: feeInWei
            });

            console.log('Transaction receipt:', txReceipt);

            // Optionally, get block info for an exact timestamp
            const block = await web3.eth.getBlock(txReceipt.blockNumber);
            const blockTimestamp = new Date(block.timestamp * 1000).toLocaleString();

            // Build the IPFS gateway link
            const ipfsLink = `https://gateway.pinata.cloud/ipfs/${ipfsHash || ''}`;

            // Generate the receipt (with a QR code)
            generateReceipt({
                fileName: lastUploadedFileName,
                ipfsHash: ipfsHash,
                docHash: hashHex,
                account: account,
                transactionHash: txReceipt.transactionHash,
                dateTime: blockTimestamp,
                ipfsLink: ipfsLink
            });
        } catch (error) {
            console.error('Error registering hash on blockchain:', error);
            alert('Error registering hash on blockchain. Check console for details.');
        } finally {
            toggleLoadingOverlay(false);
        }
    }

    // 5) Generate Receipt
    function generateReceipt({
        fileName,
        ipfsHash,
        docHash,
        account,
        transactionHash,
        dateTime,
        ipfsLink
    }) {
        const receiptContentElement = document.getElementById('receiptContent');
        const qrCodeElement = document.getElementById('qrCode');

        // Clear previous QR code
        qrCodeElement.innerHTML = '';

        const receiptHTML = `
            <strong>File Name:</strong> ${fileName}<br>
            <strong>IPFS Hash:</strong> ${ipfsHash}<br>
            <strong>Document Hash (SHA-256):</strong> ${docHash}<br>
            <strong>Registered By:</strong> ${account}<br>
            <strong>Date and Time:</strong> ${dateTime}<br>
            <strong>Transaction Hash:</strong>
            <a href="https://sepolia.etherscan.io/tx/${transactionHash}" target="_blank">
                ${transactionHash}
            </a>
        `;

        receiptContentElement.innerHTML = receiptHTML;
        document.getElementById('receipt').style.display = 'block';

        // Generate QR code for IPFS retrieval link
        new QRCode(qrCodeElement, {
            text: ipfsLink,
            width: 128,
            height: 128,
        });
    }

    // 6) Verify Document (no change)
    async function verifyDocument() {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.pdf';
        fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) {
                alert('No file selected.');
                return;
            }
            const arrayBuffer = await file.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHexToVerify =
                '0x' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            try {
                const isRegistered = await contract.methods
                    .isDocumentRegistered(hashHexToVerify)
                    .call();
                if (isRegistered) {
                    const details = await contract.methods
                        .getDocumentDetails(hashHexToVerify)
                        .call();
                    alert(
                        `Document is registered.\n` +
                        `Registrant: ${details.registrant}\n` +
                        `Timestamp: ${new Date(details.timestamp * 1000).toLocaleString()}`
                    );
                } else {
                    alert('Document is not registered.');
                }
            } catch (error) {
                console.error('Error verifying document:', error);
                alert('Error verifying document.');
            }
        };
        fileInput.click();
    }

    // 7) Check Network (Sepolia)
    async function checkNetwork() {
        const chainId = await web3.eth.getChainId();
        if (chainId !== 11155111) { // Sepolia
            try {
                await selectedProvider.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0xaa36a7' }] // 11155111 in hex
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    alert('Please add the Sepolia network to your wallet.');
                } else {
                    console.error('Error switching network:', switchError);
                }
            }
        }
    }

    // 8) React to account & chain changes
    if (window.ethereum) {
        window.ethereum.on('accountsChanged', function (accounts) {
            window.location.reload();
        });
        window.ethereum.on('chainChanged', function (chainId) {
            window.location.reload();
        });
    }

    // 10) Retrieve from IPFS (no change)
    async function retrieveDocument() {
        const ipfsHashVal = document.getElementById('retrieveHash').value.trim();
        if (!ipfsHashVal) {
            alert('Please enter an IPFS hash.');
            return;
        }
        const ipfsGatewayURL = `https://gateway.pinata.cloud/ipfs/${ipfsHashVal}`;
        const linkElement = document.getElementById('retrievedLink');

        try {
            const response = await fetch(ipfsGatewayURL, { method: 'HEAD' });
            if (response.ok) {
                linkElement.href = ipfsGatewayURL;
                linkElement.style.display = 'block';
                linkElement.innerText = 'Download Document';
            } else {
                alert('The document is not available on IPFS.');
            }
        } catch (error) {
            console.error('Error retrieving document:', error);
            alert('Failed to retrieve document. See console for details.');
        }
    }
</script>
</body>
</html>
