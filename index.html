<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>MyTitleLock - Lock Down Your Title</title>
    <!-- Include Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    
    <!-- PayPal SDK (Replace with your own CLIENT-ID) -->
    <script src="https://www.paypal.com/sdk/js?client-id=REPLACE_WITH_YOUR_PAYPAL_CLIENT_ID&currency=USD"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            margin: 0;
            padding: 0;
        }

        .navbar {
            background-color: #1e429f;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .navbar h1 {
            margin: 0;
            font-size: 24px;
            line-height: 1.2;
            color: white;
        }

        .container {
            max-width: 900px;
            margin: 40px auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        h1, h2, h3 {
            color: #1e429f;
            margin-top: 25px;
        }

        button {
            background-color: #1e429f;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        input[type="file"], input[type="text"] {
            margin: 20px 0;
            padding: 10px;
            width: calc(100% - 22px);
            box-sizing: border-box;
        }

        #fileNameOutput {
            margin: 10px 0 0;
            color: #555;
            font-style: italic;
        }

        #hashOutput {
            word-break: break-word;
            margin: 10px 0 20px;
            color: #1e429f;
        }

        #receipt {
            display: none;
            background-color: #e6f7ff;
            border: 2px solid #1e429f;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }

        .footer {
            text-align: center;
            margin-top: 50px;
            color: #777;
        }

        #retrievedLink {
            display: none;
            color: #1e429f;
            text-decoration: underline;
            margin-top: 10px;
        }

        /* Spinner Overlay Styles */
        #loadingOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .spinner {
            border: 8px solid #f3f3f3; /* Light gray */
            border-top: 8px solid #1e429f; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0%   { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* PayPal button container (hidden by default) */
        #paypal-button-container {
            display: none;
            margin-bottom: 20px;
        }

        .fee-structure {
            background-color: #f0f8ff;
            border: 1px solid #1e429f;
            padding: 10px;
            margin-top: 15px;
            border-radius: 5px;
        }

        .marketing-section {
            margin-top: 40px;
            padding: 15px;
            background: #fffcee;
            border: 1px solid #f7daa3;
            border-radius: 5px;
        }
        .marketing-section h3 {
            color: #cc6600;
            margin-top: 0;
        }
        .marketing-section ul {
            margin: 0 0 1em 1.4em;
        }
        .marketing-section strong {
            color: #cc6600;
        }
    </style>
</head>

<body>
<div class="navbar">
    <h1>MyTitleLock - Lock Down Your Title</h1>
</div>

<div class="container">
    <h2>Welcome to MyTitleLock</h2>
    <p>Manage and verify title deeds securely using blockchain and IPFS technology. By uploading a title deed, we generate a unique "hash" for the document, which acts like a digital fingerprint. This hash is stored securely on the blockchain, ensuring tamper-proof authenticity. The hashing process is a one-way mathematical function that converts your document into a fixed string of characters, making it impossible to recreate the original document from the hash. This ensures that your title deed is both private and secure, while allowing easy verification of its integrity.</p>

    <!-- New Marketing / Educational Section -->
    <div class="marketing-section">
        <h3>Why IPFS and Blockchain for Your Title Deeds?</h3>
        <p>
            <strong>IPFS (InterPlanetary File System)</strong> is a decentralized file storage and sharing protocol 
            that makes the web faster, safer, and more resilient. Instead of relying on centralized servers, IPFS 
            distributes data across a peer-to-peer network, ensuring no single point of failure.
        </p>
        <ul>
            <li><strong>Decentralized &amp; Resilient:</strong> Files are stored globally, so even if one node goes offline, 
                the data remains accessible. Perfect for critical documents like deeds or insurance records.</li>
            <li><strong>Immutable &amp; Tamper-Proof:</strong> Each file is identified by a unique cryptographic hash. Any 
                modification changes the hash, making unauthorized edits immediately detectable.</li>
            <li><strong>Cost-Efficient:</strong> IPFS pinning services are often cheaper than traditional cloud storage, 
                and you pay only for the data you want pinned. No large hosting overhead.</li>
            <li><strong>Censorship-Resistance:</strong> No central entity can remove or censor data on IPFS, vital for 
                legal documents that must remain accessible and accurate.</li>
            <li><strong>Global Accessibility:</strong> Anyone with the file’s hash can retrieve it from IPFS, making 
                cross-border title searches and verifications seamless.</li>
        </ul>
        <p>
            <strong>Blockchain Integration</strong>: By storing only the document’s hash on a blockchain, you get a 
            tamper-proof registry of ownership. Combining IPFS (for the file) with blockchain (for the record) 
            yields a trustless, immutable system for verifying title authenticity—no single authority can alter 
            the record.
        </p>
        <p>
            <em>In short, IPFS + Blockchain ensures your title documents are secure, verifiable, and always within reach 
            — a future-proof solution for property management, insurance, and beyond.</em>
        </p>
    </div>
    <!-- End Marketing Section -->

    <div class="fee-structure">
        <strong>File Size Fee Structure (PayPal):</strong><br/>
        - Up to 0.5MB: <strong>FREE</strong><br/>
        - 0.5MB &ndash; 5MB: <strong>$5</strong><br/>
        - 5MB &ndash; 20MB: <strong>$10</strong><br/>
        - 20MB &ndash; 50MB: <strong>$20</strong><br/>
        <em>Files over 50MB are not accepted.</em>
    </div>

    <h3>Step 1: Connect Your Wallet</h3>
    <button onclick="connectWallet('metamask')">Connect MetaMask</button>
    <button onclick="connectWallet('coinbase')">Connect Coinbase Wallet</button>
    <button onclick="disconnectWallet()">Disconnect Wallet</button>
    <p id="walletAddress">Not connected</p>

    <h3>Step 2: Upload and Pay (If Required)</h3>
    <input type="file" id="fileInput" accept=".pdf" />
    <!-- PayPal button container -->
    <div id="paypal-button-container"></div>

    <button id="uploadBtn" onclick="handleFileAndPayment()">Upload and Hash Document</button>

    <!-- Show file name after selection -->
    <p id="fileNameOutput"></p>
    <p id="hashOutput"></p>

    <h3>Step 3: Register Title Deed Hash on Blockchain</h3>
    <button id="registerButton" onclick="registerHashOnBlockchain()" disabled>Register on Blockchain</button>

    <div id="receipt">
        <h3>Transaction Receipt</h3>
        <p id="receiptContent"></p>
        <div id="qrCode" style="margin-top:10px;"></div>
        <p style="color:red; margin-top:15px;">
            <strong>IMPORTANT:</strong> Save or print this receipt!
            You will need the information and/or QR code to verify or retrieve your document in the future.
        </p>
    </div>

    <h3>Step 4: Verify Title Deed</h3>
    <button onclick="verifyDocument()">Verify Document</button>

    <h3>Step 5: Retrieve Title Deed</h3>
    <input type="text" id="retrieveHash" placeholder="Enter IPFS Hash" />
    <button onclick="retrieveDocument()">Retrieve Document</button>
    <a id="retrievedLink" href="#" target="_blank">Download Document</a>
</div>

<!-- Spinner Overlay -->
<div id="loadingOverlay">
    <div class="spinner"></div>
    <p style="color: white; font-size: 20px; text-align: center;">
        Processing... Please wait.
    </p>
</div>

<div class="footer">
    &copy; 2023 MyTitleLock. All Rights Reserved.
</div>

<script>
    let web3;
    let contract;
    let account;
    let hashHex;
    let ipfsHash;
    let selectedProvider;

    let lastUploadedFileName = ''; // store the file name to show in receipt
    let uploadCostUSD = 0;         // how much the user must pay based on file size
    let fileToUpload = null;       // store the actual File object for reference
    // Contract ABI
    const contractABI = [
        {
            "type": "constructor",
            "inputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "fee",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "getDocumentDetails",
            "inputs": [
                {
                    "name": "_hash",
                    "type": "bytes32",
                    "internalType": "bytes32"
                }
            ],
            "outputs": [
                {
                    "name": "hash",
                    "type": "bytes32",
                    "internalType": "bytes32"
                },
                {
                    "name": "timestamp",
                    "type": "uint256",
                    "internalType": "uint256"
                },
                {
                    "name": "registrant",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "getFee",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "isDocumentRegistered",
            "inputs": [
                {
                    "name": "_hash",
                    "type": "bytes32",
                    "internalType": "bytes32"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "bool",
                    "internalType": "bool"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "owner",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "registerDocument",
            "inputs": [
                {
                    "name": "_hash",
                    "type": "bytes32",
                    "internalType": "bytes32"
                }
            ],
            "outputs": [],
            "stateMutability": "payable"
        },
        {
            "type": "function",
            "name": "renounceOwnership",
            "inputs": [],
            "outputs": [],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "setFee",
            "inputs": [
                {
                    "name": "_newFee",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "transferOwnership",
            "inputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "outputs": [],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "withdrawFees",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "event",
            "name": "DocumentRegistered",
            "inputs": [
                {
                    "name": "hash",
                    "type": "bytes32",
                    "indexed": true,
                    "internalType": "bytes32"
                },
                {
                    "name": "registrant",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "timestamp",
                    "type": "uint256",
                    "indexed": false,
                    "internalType": "uint256"
                }
            ],
            "anonymous": false
        },
        {
            "type": "event",
            "name": "OwnershipTransferred",
            "inputs": [
                {
                    "name": "previousOwner",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "newOwner",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                }
            ],
            "anonymous": false
        },
        {
            "type": "error",
            "name": "OwnableInvalidOwner",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        },
        {
            "type": "error",
            "name": "OwnableUnauthorizedAccount",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        }
    ];

    // Contract address
    const contractAddress = '0xca2f282ab9d7b2ae33FDe040142C1c185B6591b4';

    // 1) Connect Wallet
    async function connectWallet(wallet) {
        if (wallet === 'metamask') {
            if (window.ethereum && window.ethereum.isMetaMask) {
                selectedProvider = window.ethereum;
            } else {
                alert('MetaMask is not installed. Please install MetaMask and try again.');
                return;
            }
        } else if (wallet === 'coinbase') {
            const coinbaseWallet = new CoinbaseWalletSDK({
                appName: 'LockChain',
                appLogoUrl: 'https://yourapp.com/logo.png',
                darkMode: false
            });
            const coinbaseProvider = coinbaseWallet.makeWeb3Provider();
            selectedProvider = coinbaseProvider;
        } else {
            alert('Unsupported wallet selected');
            return;
        }

        try {
            web3 = new Web3(selectedProvider);
            await selectedProvider.request({ method: 'eth_requestAccounts' });
            const accounts = await web3.eth.getAccounts();
            account = accounts[0];
            document.getElementById('walletAddress').innerText = 'Connected: ' + account;
            contract = new web3.eth.Contract(contractABI, contractAddress);

            // Check network
            await checkNetwork();
            // Fetch and display fee
            await displayCurrentFee();

            console.log('Connected account:', account);
        } catch (error) {
            console.error('Error connecting to wallet:', error);
            alert('Error connecting to wallet.');
        }
    }

    // 2) Disconnect Wallet
    function disconnectWallet() {
        if (selectedProvider && selectedProvider.close) {
            selectedProvider.close();
        }
        selectedProvider = null;
        web3 = null;
        account = null;
        document.getElementById('walletAddress').innerText = 'Not connected';
        alert('Wallet disconnected');
    }

    // 3) Display Current Fee (on the smart contract side)
    async function displayCurrentFee() {
        try {
            const feeInWei = await contract.methods.getFee().call();
            const feeInEth = web3.utils.fromWei(feeInWei, 'ether');

            const feeNotice = document.createElement('p');
            feeNotice.id = 'feeNotice';
            feeNotice.innerText =
                `A small fee of ${feeInEth} ETH is required to register your document on the blockchain.`;

            const container = document.querySelector('.container');
            container.appendChild(feeNotice);
        } catch (error) {
            console.error('Error fetching current fee:', error);
            alert('Error fetching current fee from the contract.');
        }
    }

    // Loading Overlay
    function toggleLoadingOverlay(show) {
        const loadingOverlay = document.getElementById('loadingOverlay');
        if (loadingOverlay) {
            loadingOverlay.style.display = show ? 'flex' : 'none';
        }
    }

    // Adjusted Fee Logic: Up to 0.5MB is free, 0.5–5MB => $5, 5–20MB => $10, 20–50MB => $20
    function determineFeeBySize(fileSizeBytes) {
        const sizeMB = fileSizeBytes / (1024 * 1024); // convert bytes to MB
        if (sizeMB > 50) {
            alert('File too large! Max limit is 50 MB.');
            return -1; // indicates an invalid file
        }
        if (sizeMB <= 0.5) {
            return 0;
        } else if (sizeMB <= 5) {
            return 5;
        } else if (sizeMB <= 20) {
            return 10;
        } else {
            // up to 50 MB
            return 20;
        }
    }

    // Step 2: Called when user clicks "Upload and Hash Document"
    async function handleFileAndPayment() {
        const fileInput = document.getElementById('fileInput');
        const selectedFile = fileInput.files[0];
        if (!selectedFile) {
            alert('Please select a PDF file first.');
            return;
        }
        // Check the size + fee
        const fee = determineFeeBySize(selectedFile.size);
        if (fee < 0) {
            // invalid file
            return;
        }
        fileToUpload = selectedFile;    // store globally
        uploadCostUSD = fee;           // store the cost

        // Show the file name
        lastUploadedFileName = selectedFile.name;
        document.getElementById('fileNameOutput').innerText = `File Name: ${selectedFile.name}`;

        if (fee === 0) {
            // No PayPal payment needed => directly upload to IPFS
            await uploadToIPFS();
        } else {
            // Show PayPal button for the fee
            showPayPalButton(fee);
        }
    }

    // Render the PayPal button for the given amount
    function showPayPalButton(amountUSD) {
        const paypalContainer = document.getElementById('paypal-button-container');
        paypalContainer.style.display = 'block'; // make it visible

        // Clean up any previously rendered button
        paypalContainer.innerHTML = '';

        paypal.Buttons({
            style: {
                layout: 'vertical',
                color: 'gold',
                shape: 'pill',
                label: 'paypal'
            },
            createOrder: function (data, actions) {
                return actions.order.create({
                    purchase_units: [{
                        amount: { value: amountUSD.toString() }
                    }]
                });
            },
            onApprove: function (data, actions) {
                return actions.order.capture().then(function (details) {
                    // Payment completed => now proceed with the IPFS upload
                    paypalContainer.style.display = 'none'; // hide PayPal UI
                    alert('Payment successful! Uploading file to IPFS...');
                    uploadToIPFS();
                });
            },
            onCancel: function (data) {
                alert('Payment canceled.');
            },
            onError: function (err) {
                console.error('PayPal error:', err);
                alert('An error occurred with PayPal. Check console for details.');
            }
        }).render('#paypal-button-container');
    }

    // 9) Actually upload to IPFS (after PayPal or if free)
    async function uploadToIPFS() {
        if (!fileToUpload) {
            alert('No file is selected. Please select a file first.');
            return;
        }
        toggleLoadingOverlay(true);
        try {
            const formData = new FormData();
            formData.append('file', fileToUpload);

            const response = await fetch(
                'https://polar-stream-23993-43b80ccd3a73.herokuapp.com/upload',
                {
                    method: 'POST',
                    body: formData
                }
            );
            if (!response.ok) {
                throw new Error('Failed to upload file to server.');
            }
            const data = await response.json();

            // IPFS Hash (from Pinata)
            ipfsHash = data.IpfsHash;
            document.getElementById('hashOutput').innerText = `IPFS Hash: ${ipfsHash}`;

            // Now do a separate SHA-256 of the file for the contract
            const arrayBuffer = await fileToUpload.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            hashHex = '0x' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            // Enable the "Register on Blockchain" button
            document.getElementById('registerButton').disabled = false;

            // Clear out fileToUpload (not strictly necessary)
            fileToUpload = null;
        } catch (error) {
            console.error('Error uploading file:', error);
            alert('Failed to upload file. Please try again.');
        } finally {
            toggleLoadingOverlay(false);
        }
    }

    // 4) Register Hash on Blockchain
    async function registerHashOnBlockchain() {
        if (!web3 || !account) {
            alert('Please connect your wallet first.');
            return;
        }
        if (!hashHex) {
            alert('Please hash a document first.');
            return;
        }

        toggleLoadingOverlay(true);
        try {
            const isRegistered = await contract.methods.isDocumentRegistered(hashHex).call();
            if (isRegistered) {
                alert('This document is already registered.');
                return;
            }

            // Get current fee from the contract (in ETH)
            const feeInWei = await contract.methods.getFee().call();

            // Send transaction
            const txReceipt = await contract.methods.registerDocument(hashHex).send({
                from: account,
                value: feeInWei
            });

            console.log('Transaction receipt:', txReceipt);

            // Optionally, get block info for an exact timestamp
            const block = await web3.eth.getBlock(txReceipt.blockNumber);
            const blockTimestamp = new Date(block.timestamp * 1000).toLocaleString();

            // Build the IPFS gateway link
            const ipfsLink = `https://gateway.pinata.cloud/ipfs/${ipfsHash || ''}`;

            // Generate the receipt (with a QR code)
            generateReceipt({
                fileName: lastUploadedFileName,
                ipfsHash: ipfsHash,
                docHash: hashHex,
                account: account,
                transactionHash: txReceipt.transactionHash,
                dateTime: blockTimestamp,
                ipfsLink: ipfsLink
            });
        } catch (error) {
            console.error('Error registering hash on blockchain:', error);
            alert('Error registering hash on blockchain. Check console for details.');
        } finally {
            toggleLoadingOverlay(false);
        }
    }

    // 5) Generate Receipt
    function generateReceipt({
        fileName,
        ipfsHash,
        docHash,
        account,
        transactionHash,
        dateTime,
        ipfsLink
    }) {
        const receiptContentElement = document.getElementById('receiptContent');
        const qrCodeElement = document.getElementById('qrCode');

        // Clear previous QR code
        qrCodeElement.innerHTML = '';

        const receiptHTML = `
            <strong>File Name:</strong> ${fileName}<br>
            <strong>IPFS Hash:</strong> ${ipfsHash}<br>
            <strong>Document Hash (SHA-256):</strong> ${docHash}<br>
            <strong>Registered By:</strong> ${account}<br>
            <strong>Date and Time:</strong> ${dateTime}<br>
            <strong>Transaction Hash:</strong>
            <a href="https://sepolia.etherscan.io/tx/${transactionHash}" target="_blank">
                ${transactionHash}
            </a>
        `;

        receiptContentElement.innerHTML = receiptHTML;
        document.getElementById('receipt').style.display = 'block';

        // Generate QR code for IPFS retrieval link
        new QRCode(qrCodeElement, {
            text: ipfsLink,
            width: 128,
            height: 128,
        });
    }

    // 6) Verify Document (no change)
    async function verifyDocument() {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.pdf';
        fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) {
                alert('No file selected.');
                return;
            }
            const arrayBuffer = await file.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHexToVerify =
                '0x' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            try {
                const isRegistered = await contract.methods
                    .isDocumentRegistered(hashHexToVerify)
                    .call();
                if (isRegistered) {
                    const details = await contract.methods
                        .getDocumentDetails(hashHexToVerify)
                        .call();
                    alert(
                        `Document is registered.\n` +
                        `Registrant: ${details.registrant}\n` +
                        `Timestamp: ${new Date(details.timestamp * 1000).toLocaleString()}`
                    );
                } else {
                    alert('Document is not registered.');
                }
            } catch (error) {
                console.error('Error verifying document:', error);
                alert('Error verifying document.');
            }
        };
        fileInput.click();
    }

    // 7) Check Network (Sepolia)
    async function checkNetwork() {
        const chainId = await web3.eth.getChainId();
        if (chainId !== 11155111) { // Sepolia
            try {
                await selectedProvider.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0xaa36a7' }] // 11155111 in hex
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    alert('Please add the Sepolia network to your wallet.');
                } else {
                    console.error('Error switching network:', switchError);
                }
            }
        }
    }

    // 8) React to account & chain changes
    if (window.ethereum) {
        window.ethereum.on('accountsChanged', function (accounts) {
            window.location.reload();
        });
        window.ethereum.on('chainChanged', function (chainId) {
            window.location.reload();
        });
    }

    // 10) Retrieve from IPFS (no change)
    async function retrieveDocument() {
        const ipfsHashVal = document.getElementById('retrieveHash').value.trim();
        if (!ipfsHashVal) {
            alert('Please enter an IPFS hash.');
            return;
        }
        const ipfsGatewayURL = `https://gateway.pinata.cloud/ipfs/${ipfsHashVal}`;
        const linkElement = document.getElementById('retrievedLink');

        try {
            const response = await fetch(ipfsGatewayURL, { method: 'HEAD' });
            if (response.ok) {
                linkElement.href = ipfsGatewayURL;
                linkElement.style.display = 'block';
                linkElement.innerText = 'Download Document';
            } else {
                alert('The document is not available on IPFS.');
            }
        } catch (error) {
            console.error('Error retrieving document:', error);
            alert('Failed to retrieve document. See console for details.');
        }
    }
</script>
</body>
</html>
